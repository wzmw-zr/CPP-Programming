# 模板的使用与行为

**==模板在编译期间被处理。==**



## 一、模板的使用

模板具有**（1）隐式调用（2）显式调用** 两种调用方式。

隐式调用就是不加任何关于数据类型的信息的调用，而显式调用则是`name<type,type...>(var1, var2...)`这种形式的，**在`<>`中显式指明各个参数的类型。**

``` c++
template<typename T>
T add(T a, T b) {
    cout << "add function : " << sizeof(T) << endl; 
    return a + b;
}

int main() {
    // 隐式模板调用
    cout << add(2, 3) << endl;
    cout << add(2.3, 4.5) << endl;
    // 显式模板调用
    cout << add<double>(2.3, 5) << endl;
    return 0;
}
```

**模板根据类型生成代码，但是对于类型参数相同的，只会生成一次，因此==对于实际类型相同的模板调用，不论是隐式调用还是显式调用，使用的实际上是同一份代码==。**



## 二、模板在预编译阶段的行为

**首先，==模板在编译得到的对象文件中是已经不存在的==。**

**模板真正的作用：==在调用相关模板时，模板就会进行类型推导，在程序中生成相关的代码==。而在真正进行编译的时候，就已经没有模板了。**

这样看来模板的作用与宏定义的作用差不多，但是模板比宏要强大很多，原因在于：
**模板是具有具体的计算逻辑的，而宏定义仅仅是替换功能，所以==在制造代码方面，模板比宏要强大很多。==**

